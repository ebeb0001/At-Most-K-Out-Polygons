<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>At most K-out polygons - Algorithm</title>
		<script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
		<link rel="stylesheet" href="../styling.css" />
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
		<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"> </script>
	</head>

	<body>
		<header class="site-header card">
			<div class="title">
				<div>
					<h1>At Most k-Out Polygons</h1>
				</div>
			</div>

			<nav class="nav">
				<a href="../index.html">Home</a>
				<a href="./playground.html">Playground</a>
				<a href="./algorithm.html" >Algorithm</a>
				<a href="./about.html">About</a>
			</nav>
		</header>

		<main class="container">
			<section class="hero card">
				<div>
					<h2>Prerequisites</h2>
					<p>To fully understand how the algorithm works, this section will shortly explain the primitives used.</p>
					<h3>Point Set</h3>
					<p>A point set S, to put it simply, is like a bag full of pairs of coordinates that represent the positions of the different points on a plane. 
						This set needs to abide by a rule though, and it's that it's assumed to have general position, which simply means that no 3 points can be collinear.</p>

					<h3>Simple Polygon</h3>
					<p>A simple polygon is a polygon that does not intersect itself. In other words, the edges of the polygon can only meet at their endpoints, 
						and the polygon encloses a single continuous area with no holes.</p>


					<h3>Inside/Outside</h3>
					<p>This one is rather self explanatory. The points of the set S that are strictly inside of the borders of a given polygon are considered In(P)
						and for the points that are strictly outside of said borders, they are considered as you would guess, Out(P). It's good to note that vertices of 
						the given polygon P are neither in In(P) nor in Out(P). </p>
					<h3>At-most-k-out Polygon</h3>
					<p>By understanding the previous definitions, we can now define what an at-most-k-out polygon is. An at-most-k-out polygon P is a simple polygon such 
					that the number of points from the point set S that lie outside of P is at most k (where k is a given integer), i.e. : </p>
					<div style="text-align:center;">$$|\mathrm{out}(P)| \le k.$$</div> 
					<p>A nice way to understand it is by thinking of the edges of the polygon as being a fence that enclose the In(P) points and leaving out at most k points in Out(P) </p>


					<h3>Convex Hull</h3>
					<p>By using the definitions as building blocks we progressively introduce more complex definitions. The convex hull of a point set S is the smallest convex polygon that can enclose all the points in S, 
						which means that all the points in S are either 
					on the boundary of the polygon or inside it, leaving Out(P) empty. You can think of it as the shape formed by stretching a rubber band around the outermost points in the set S. 
					The convex hull is important because it provides a boundary that contains all the points in S, and is often used as a starting point for various geometric algorithms, including the one presented in this demo.
					</p>

				</div>
			</section>
            <section class="hero card">
				<div>
					<h2>Enumeration Algorithm</h2>
					<p>A high level explanation of how to enumerate all of the at-most-k-out polygons is by using a tree. The set of all possible at-most-k-out polygons is 
						grouped into a family tree with the following structure:</p>
						<ul>
						<li>Node : An at-most-k-out polygon.</li>
						<li>Root : The Convex Hull CH(S) of the set S.</li>
						<li>Edge : the relation parent-child.</li>
						</ul>

						<p>With now a little bit of the structure in mind we can continue by defining other notions that will be needed for the algorithm like the concepts of embeddable and insertable.
													</p>

						<h3>Embeddable</h3>
						<p>
							An embeddable vertex is basically a corner of the polygon that we can safely
							straighten out. More precisely, take a vertex <em>p<sub>i</sub></em> of a polygon <em>P</em>
							and look at the small triangle formed by its two neighbours,
							<em>pred(p<sub>i</sub>)</em> and <em>succ(p<sub>i</sub>)</em>. If this triangle lies completely
							inside <em>P</em> and does not contain any point from <strong><code>out(P)</code></strong>, then
							<em>p<sub>i</sub></em> is called an <strong>embeddable</strong> vertex.
						</p>

						<p>
							Embedding an embeddable vertex just means removing that tiny ear. We delete the
							two edges <em>(pred(p<sub>i</sub>), p<sub>i</sub>)</em> and <em>(p<sub>i</sub>, succ(p<sub>i</sub>))</em> and
							replace them with a single edge <em>(pred(p<sub>i</sub>) to succ(p<sub>i</sub>))</em>, which keeps
							the polygon simple and keeps the at-most-k-out property.
						</p>

						<h3>Insertable</h3>
						<p>It uses kind of the same logic as embedding but this time we search for points that are in <strong><code>out(P)</code></strong> and with the same kind of manoeuvre by
						creating a temporary triangle and if this triangle doesn't include other outside points and doesn't intersect P then we can add that point as a new vertex of the polygon P. </p>

						<h3>Largest Embeddable Vertex</h3>
						<p>When a polygoon P has more than one embeddable vertex, we need a way that is consistent to find which one to embed first. To achieve this we assume the vertices of P are
						ordered in counter-clockwise order, starting from a fixed point. If we do a walk on the polygon in this order and mark every single embeddable vertex,
						the largest embeddable vertex is defined as the embeddable vertex with the highest index in this order, i.e. the last embeddable vertex we find in our walk. This is the corner 
						we will emebed first when doing the parent function par(P).</p>

						<h3>Insertable Outside Point</h3>
						<p>As explained in the insertable section, there are conditions to be able to insert a point from <strong><code>out(P)</code></strong> into the polygon P.
						The set of points that satisfy the conditions are called insertable outisde points, so <strong><code>iout(P)</code></strong> contains exactly the outside
						points that can be inserted into P without violating the at-most-k-out property. </p>

						<h3>Closest Outisde Point</h3>
						<p>Among all of the instertable outside points, we still need a way to choose one in a deterministic way. The method used is to iterate over
							the the insertable points <strong>p</strong>, then look at the edge where they would be inserted (by using <strong><code>cloe(P,p)</code></strong> which is the closest edge insertable from <strong>p</strong>), and measure the distance from the point to that
							edge. We measure it by using Euclidean distance to the midpoint to the edge from the point <strong>p</strong>. Then we define <strong><code>clop(P)</code></strong> as the point with the smallest distance. This is the point we will insert when P has 
							no embeddable vertices adn we want to move to its parent.
						</p>

						<h3>Parent Function</h3>
						<p>Now that we introduced all of the local moves to move inside of the tree, we can introduce the parent function <code>par(P)</code> that is used to navigate the family tree.
							The parent function is necessary to define the tree structure so that each node has a unique parent. The function is defined as follows:
						</p>
						<div style="text-align:center; margin-top: 12px;">
						$$\operatorname{par}(P) :=
						\begin{cases}
							\operatorname{emb}\!\big(P, \operatorname{larg}(P)\big),
							& \text{if $P$ has an embeddable vertex},\\[4pt]
							\operatorname{ins}\!\big(P, \operatorname{cloe}(P, \operatorname{clop}(P)), \operatorname{clop}(P)\big),
							& \text{otherwise.}
						\end{cases}
						$$
						</div>
						<p>The two cases are pretty straightforward, the parent function will first try embed the largest vertex, i.e., the last vertex visited on a walk
							along the polygon in counter-clockwise order. The idea is to try to straighten the polygon as much as possible before trying to add outside vertices.
							If there are no embeddable vertices at all, then we insert the closest outside point into the polygon by using helper functions previously defined like 
							<code>cloe(P,p)</code> and <code>clop(P)</code> to determine which point to insert and where to insert it. Because we setup these rules it allows us to avoid having 
							multiple parents for a single node, which is crucial.
						</p>

						<p>
							Starting from any at-most-k-out polygon P, we can repeatedly apply the parent function to get a kind of chain of polygons which is called 
							a <strong>parent sequence</strong>. This sequence will always end at the root of the three, which is the convex hull <strong><code>CH(S)</code></strong>.
							By merging all of these sequences together for every possible at-most-k-out polygon, we get the full family tree of at-most-k-out polygons joined at the root. 
							Then simply by inversing the direction of the arrows we get a tree where the edges point from parent to child.
						</p>

						<h3>Children Function</h3>
						<p>So now that we have a way of getting to the parent of any polygon, we need a way to get, for a given polygon P, all of the children whose parent is P.
							We will define two helper functions, <strong><code>dig()</code></strong> and <strong><code>remove()</code></strong>.
						</p>

						<h3>Dig Function</h3>
						<p>The <strong><code>dig()</code></strong> function is the opposite of the embed operation. It takes a digable pair (p<sub>i</sub>, p) of a polygon P and removes the edge (p<sub>i</sub>, succ(p<sub>i</sub>)) to create two
							new edges (p<sub>i</sub>, p) and (p, succ(p<sub>i</sub>)). This operation adds a new vertex p to the polygon P while keeping it simple and maintaining the at-most-k-out property. It was mentioned
							that it's the opposite of embed because if we were to apply embed on the newly created polygon at vertex p, we would get back the original polygon P.
						</p>

						<h3>Remove Function</h3>
						<p>
						The <strong><code>rmv()</code></strong> function is the opposite of the insert operation. By taking a vertex <strong>p</strong> of the polygon P as well as its neighbours
						<em>pred(p<sub>i</sub>)</em> and <em>succ(p<sub>i</sub>)</em>, we can create a triangle formed by these three points. If this triangle lies inside of P and contains no points from the
						set of points <em><strong>S</strong></em> and the size of the set <strong><code>out(P)</code></strong> strictly less than <strong>k</strong>, then we can remove the two edges
						<em>(pred(p<sub>i</sub>), p<sub>i</sub>)</em> and <em>(p<sub>i</sub>, succ(p<sub>i</sub>))</em> and replace them with a single edge <em>(pred(p<sub>i</sub>) to succ(p<sub>i</sub>))</em>.
						This operation removes the vertex <strong>p</strong> from the polygon P and increases the size of the set <strong><code>out(P)</code></strong> by one, while keeping the polygon simple and maintaining the at-most-k-out property.
						</p>

						<h3>Active Children</h3>
						<p>A move is called active if it can be reversed by applying the parent function. In other words, a digable pair (p<sub>i</sub>, p) of a polygon P is active if
						applying the parent function to the polygon obtained by <strong>digging</strong> at (p<sub>i</sub>, p) returns the original polygon P. Similarly, a vertex p of a polygon P is active if
						applying the parent function to the polygon obtained by <strong>removing</strong> p returns the original polygon P. It's just a way to show that the move is valid and can be reversed, it's like a DNA test for moves.
						</p>	

						<h3>Enumeration / Traversal</h3>
						<p>
						Now that we have all of the necessary building blocks, we can finally explain how to enumerate all of the at-most-k-out polygons. The idea is to do a depth-first traversal of the tree
						starting from the root, which is the convex hull <strong><code>CH(S)</code></strong> as previously explained. At each polygon P we will generate its children by applying the <strong>dig()</strong> and <strong>rmv()</strong>
						functions on all possible active digable pairs and active vertices respectively. This will generate all of the children of P which will be filtered to keep only the active ones. Then we will recursively apply the same process to each child polygon until all polygons have been visited.
						The algorithm used to traverse the tree is a standard DFS.
						</p>

						<p>
							Once the tree has been fully generated and traversed, we will have enumerated all of the at-most-k-out polygons for the given point set S. This algorithm is efficient because it avoids generating duplicate polygons and only visits each polygon once.
						</p>


				</div>
			</section>
        </main>


</html>